interface CommonSerializeOptions {
    checkKeys?: boolean;
    serializeFunctions?: boolean;
    ignoreUndefined?: boolean;
}

export interface SerializeOptions extends CommonSerializeOptions {
    minInternalBufferSize?: number;
}

export interface SerializeWithBufferAndIndexOptions extends CommonSerializeOptions {
    index?: number;
}

export interface DeserializeOptions {
    evalFunctions?: boolean;
    cacheFunctions?: boolean;
    cacheFunctionsCrc32?: boolean;
    promoteLongs?: boolean;
    promoteBuffers?: boolean;
    promoteValues?: boolean;
    fieldsAsRaw?: { readonly [fieldName: string]: boolean };
    bsonRegExp?: boolean;
    allowObjectSmallerThanBufferSize?: boolean;
}

export interface CalculateObjectSizeOptions {
    serializeFunctions?: boolean;
    ignoreUndefined?: boolean;
}

export function serialize(object: any, options?: SerializeOptions): Buffer;

export function serializeWithBufferAndIndex(object: any, buffer: Buffer, options?: SerializeWithBufferAndIndexOptions): number;

export function deserialize(buffer: Buffer, options?: DeserializeOptions): any;

export function calculateObjectSize(object: any, options?: CalculateObjectSizeOptions): number;

export function deserializeStream(
    data: Buffer,
    startIndex: number,
    numberOfDocuments: number,
    documents: Array<any>,
    docStartIndex: number,
    options?: DeserializeOptions
): number;

export class Binary {
    static readonly SUBTYPE_DEFAULT: number;
    static readonly SUBTYPE_FUNCTION: number;
    static readonly SUBTYPE_BYTE_ARRAY: number;
    static readonly SUBTYPE_UUID_OLD: number;
    static readonly SUBTYPE_UUID: number;
    static readonly SUBTYPE_MD5: number;
    static readonly SUBTYPE_USER_DEFINED: number;
    constructor(buffer: Buffer, subType?: number);
    readonly buffer: Buffer;
    readonly sub_type?: number;
    length(): number;
    put(byte_value: number | string): void;
    read(position: number, length: number): Buffer;
    value(): string;
    write(buffer: Buffer | string, offset: number): void;
}

export class Code {
    constructor(code: string | Function, scope?: any);
    readonly code: string | Function;
    readonly scope?: any;
}

export class DBRef {
    constructor(namespace: string, oid: ObjectId, db?: string);
    namespace: string;
    oid: ObjectId;
    db?: string;
}

export class Double {
    constructor(value: number);
    value: number;
    valueOf(): number;
}

export class Int32 {
    constructor(value: number);
    valueOf(): number;
}

declare class LongLike<T> {
    constructor(low: number, high: number);
    add(other: T): T;
    and(other: T): T;
    compare(other: T): number;
    div(other: T): T;
    equals(other: T): boolean;
    getHighBits(): number;
    getLowBits(): number;
    getLowBitsUnsigned(): number;
    getNumBitsAbs(): number;
    greaterThan(other: T): boolean;
    greaterThanOrEqual(other: T): boolean;
    isNegative(): boolean;
    isOdd(): boolean;
    isZero(): boolean;
    lessThan(other: T): boolean;
    lessThanOrEqual(other: T): boolean;
    modulo(other: T): T;
    multiply(other: T): T;
    negate(): T;
    not(): T;
    notEquals(other: T): boolean;
    or(other: T): T;
    shiftLeft(numBits: number): T;
    shiftRight(numBits: number): T;
    shiftRightUnsigned(numBits: number): T;
    subtract(other: T): T;
    toInt(): number;
    toJSON(): string;
    toNumber(): number;
    toString(radix?: number): string;
    xor(other: T): T;
}

export class Long extends LongLike<Long> {
    static readonly MAX_VALUE: Long;
    static readonly MIN_VALUE: Long;
    static readonly NEG_ONE: Long;
    static readonly ONE: Long;
    static readonly ZERO: Long;
    static fromInt(i: number): Long;
    static fromNumber(n: number): Long;
    static fromBits(lowBits: number, highBits: number): Long;
    static fromString(s: string, opt_radix?: number): Long;
}

export class Decimal128 {
    static fromString(s: string): Decimal128;
    constructor(bytes: Buffer);
    readonly bytes: Buffer;
    toJSON(): string;
    toString(): string;
}

export class MaxKey {
    constructor();
}

export class MinKey {
    constructor();
}

export class ObjectId {
    constructor(id?: string | number | ObjectId);
    generationTime: number;
    static cacheHexString?: boolean;
    static createFromHexString(hexString: string): ObjectId;
    static createFromTime(time: number): ObjectId;
    static isValid(id: string | number | ObjectId): boolean;
    equals(otherID: ObjectId | string): boolean;
    static generate(time?: number): Buffer;
    getTimestamp(): Date;
    toHexString(): string;
}

export { ObjectId as ObjectID };

export class BSONRegExp {
    constructor(pattern: string, options: string);
    readonly pattern: string;
    readonly options: string;
}

export class Symbol {
    constructor(value: string);
    valueOf(): string;
}

export class Timestamp extends LongLike<Timestamp> {
    static readonly MAX_VALUE: Timestamp;
    static readonly MIN_VALUE: Timestamp;
    static readonly NEG_ONE: Timestamp;
    static readonly ONE: Timestamp;
    static readonly ZERO: Timestamp;
    static fromInt(value: number): Timestamp;
    static fromNumber(value: number): Timestamp;
    static fromBits(lowBits: number, highBits: number): Timestamp;
    static fromString(str: string, opt_radix?: number): Timestamp;
}

export namespace EJSON {
    export function parse(text: string, options?: {relaxed?: boolean;}): {};
    export function deserialize(ejson: {}, options?: {relaxed?: boolean;}): {};
    export function serialize(bson: {}, options?: {relaxed?: boolean;}): {};
    export function stringify(
        value: {},
        options?: {relaxed?: boolean;}
    ): string;
    export function stringify(
        value: {},
        replacer: ((key: string, value: any) => any) | Array<string|number> | null | undefined,
        options?: {relaxed?: boolean;}
    ): string;
    export function stringify(
        value: {},
        replacer: ((key: string, value: any) => any) | Array<string | number> | null | undefined,
        indents?: string | number,
        options?: {relaxed?: boolean;}
        ): string;
}
